<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Unique Infinite 3D Terrain</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/josephg/noisejs/perlin.js"></script>
  </head>
  <body style="margin: 0; overflow: hidden">
    <script>
      // Set up the scene, camera, and renderer
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      const renderer = new THREE.WebGLRenderer();
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Terrain parameters
      const gridSize = 200;
      const terrainGeometry = new THREE.PlaneGeometry(
        gridSize,
        gridSize,
        gridSize,
        gridSize
      );

      // Set random seed for Perlin noise
      const randomSeed = Math.random();
      noise.seed(randomSeed);

      // Perlin noise parameters
      const noiseScale = 10;
      const heightMultiplier = 10;
      let offsetX = 0;
      let offsetY = 0;
      const movementThreshold = 100;

      // Update terrain based on Perlin noise
      function updateTerrain() {
        for (let i = 0; i < terrainGeometry.attributes.position.count; i++) {
          const x = (terrainGeometry.attributes.position.getX(i) / noiseScale) + offsetX;
          const y = (terrainGeometry.attributes.position.getY(i) / noiseScale) + offsetY;
          const height = noise.perlin2(x, y) * heightMultiplier;
          terrainGeometry.attributes.position.setZ(i, height);
        }
        terrainGeometry.attributes.position.needsUpdate = true;
        terrainGeometry.computeVertexNormals();
      }

      // Load terrain texture
      const textureLoader = new THREE.TextureLoader();
      const terrainTexture = textureLoader.load("moss.webp");
      terrainTexture.wrapS = terrainTexture.wrapT = THREE.RepeatWrapping;
      terrainTexture.repeat.set(20, 20);

      const terrainMaterial = new THREE.MeshStandardMaterial({
        map: terrainTexture,
        flatShading: true,
      });

      // Create terrain mesh
      const terrain = new THREE.Mesh(terrainGeometry, terrainMaterial);
      terrain.rotation.x = -Math.PI / 2;
      scene.add(terrain);

      // Lighting setup
      const light = new THREE.DirectionalLight(0xffffff, 1);
      light.position.set(50, 50, 50);
      scene.add(light);
      const ambientLight = new THREE.AmbientLight(0x404040, 2);
      scene.add(ambientLight);

      // Camera settings and movement
      const speed = 0.5; // Walking speed
      let isMovingForward = false;
      let isMovingBackward = false;
      let isMovingLeft = false;
      let isMovingRight = false;
      camera.position.set(0, 10, 30);
      camera.lookAt(new THREE.Vector3(0, 0, 0));

      // Get terrain height at given camera position
      function getTerrainHeight(x, z) {
        const noiseX = x / noiseScale;
        const noiseZ = z / noiseScale;
        return noise.perlin2(noiseX, noiseZ) * heightMultiplier;
      }

      // Update camera height to match terrain height
      function updateCameraPosition() {
        if (isMovingForward) camera.position.z -= speed;
        if (isMovingBackward) camera.position.z += speed;
        if (isMovingLeft) camera.position.x -= speed;
        if (isMovingRight) camera.position.x += speed;

        // Update camera's y-position based on terrain height
        const terrainHeight = getTerrainHeight(camera.position.x, camera.position.z);
        camera.position.y = terrainHeight + 5; // Adjusted to keep camera above the terrain
      }

      // Update terrain offsets for infinite scrolling effect
      function updateOffsets() {
        // Adjust the offset when the camera moves beyond the threshold
        if (Math.abs(camera.position.x) > movementThreshold) {
          offsetX += (camera.position.x > 0 ? 1 : -1) * movementThreshold;
          camera.position.x = camera.position.x > 0 ? -movementThreshold : movementThreshold;
        }

        if (Math.abs(camera.position.z) > movementThreshold) {
          offsetY += (camera.position.z > 0 ? 1 : -1) * movementThreshold;
          camera.position.z = camera.position.z > 0 ? -movementThreshold : movementThreshold;
        }
      }

      // Render loop
      function animate() {
        requestAnimationFrame(animate);

        updateTerrain();
        updateOffsets();
        updateCameraPosition();

        renderer.render(scene, camera);
      }

      animate();

      // Keydown and keyup events for camera movement
      window.addEventListener("keydown", (event) => {
        if (event.key === "w") isMovingForward = true;
        if (event.key === "s") isMovingBackward = true;
        if (event.key === "a") isMovingLeft = true;
        if (event.key === "d") isMovingRight = true;
      });
      window.addEventListener("keyup", (event) => {
        if (event.key === "w") isMovingForward = false;
        if (event.key === "s") isMovingBackward = false;
        if (event.key === "a") isMovingLeft = false;
        if (event.key === "d") isMovingRight = false;
      });

      // Resize handling
      window.addEventListener("resize", () => {
        renderer.setSize(window.innerWidth, window.innerHeight);
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
      });
    </script>
  </body>
</html>

